{"version":3,"sources":["index.js"],"names":["STORAGE_KEY","formRef","document","querySelector","textareaRef","nameInputRef","checkboxRef","getElementById","formData","onFormInput","e","preventDefault","currentTarget","reset","localStorage","removeItem","onAllFormsInput","target","name","value","setItem","JSON","stringify","populateTextarea","savedMessage","parse","getItem","message","checked","agreement","throttle","func","ms","isThrottled","savedArgs","savedThis","wrapper","arguments","apply","setTimeout","addEventListener"],"mappings":";AAOA,MAAMA,EAAc,mBAEdC,EAAUC,SAASC,cAAc,qBACjCC,EAAcF,SAASC,cAAc,8BACrCE,EAAeH,SAASC,cAAc,wCACtCG,EAAcJ,SAASK,eAAe,eAEtCC,EAAW,GASjB,SAASC,EAAYC,GACnBA,EAAEC,iBACFD,EAAEE,cAAcC,QAChBC,aAAaC,WAAWf,GAM1B,SAASgB,EAAgBN,GACvBF,EAASE,EAAEO,OAAOC,MAAQR,EAAEO,OAAOE,MACnCL,aAAaM,QAAQpB,EAAaqB,KAAKC,UAAUd,IAUnD,SAASe,IACDC,MAAAA,EAAeH,KAAKI,MAAMX,aAAaY,QAAQ1B,IAGjDwB,IACFnB,EAAac,MAAQK,EAAaN,KAClCd,EAAYe,MAAQK,EAAaG,QAMjCrB,EAAYsB,UAAUJ,EAAaK,WAavC,SAASC,EAASC,EAAMC,GAClBC,IACAC,EACAC,EAFAF,GAAc,EAyBXG,OArBEA,SAAAA,IACHH,GAAAA,EAIF,OAFAC,EAAYG,eACZF,EAAY,MAIdJ,EAAKO,MAAM,KAAMD,WAEjBJ,GAAc,EAEdM,WAAW,WACTN,GAAc,EACVC,IACFE,EAAQE,MAAMH,EAAWD,GACzBA,EAAYC,EAAY,OAEzBH,IA5EP1B,EAAYsB,SAAU,EAYtB3B,EAAQuC,iBAAiB,SAAU/B,GAQnCR,EAAQuC,iBAAiB,QAASV,EAASd,EAAiB,MA8B5DO","file":"src.912e9542.js","sourceRoot":"../src","sourcesContent":["// import throttle from 'lodash.throttle';\n\n// импорты js положено ставить выше css\n// если это обычный css (не sass, module и т.д.), то его подключают к js только на время разработки, а так только к html. js не понимает css и если нет парсера любого(webpack или parcel), то такой код упадет.\n\n// константа - константное значение между разными запусками скрипта\n// глобальная константа через Upper Case + Kebab Case должна быть или в самом верху, сразу после импортов или вообще в другом файле типа constants.js и в импорте извлекаться(import { STORAGE_KEY } from './constants,js';)\nconst STORAGE_KEY = 'feedback-message';\n\nconst formRef = document.querySelector('.js-feedback-form'); //вся форма\nconst textareaRef = document.querySelector('.js-feedback-form textarea'); //только текстареа\nconst nameInputRef = document.querySelector('.js-feedback-form input[name=\"name\"]'); //только инпут для ввода имени\nconst checkboxRef = document.getElementById('user-choise'); //только чекбокс\n\nconst formData = {};\n\ncheckboxRef.checked = false;\n\n/*\n * - 1. Остановить(запретить) поведение по умолчанию\n * - 2. Убираем сообщение из хранилища (метод reset - сбрасывает значение всех полей в начальное значение)\n * - 3. Очищаем форму после отправки сообщения (oчищаем localStorage)\n */\nfunction onFormInput(e) {\n  e.preventDefault(); //1.\n  e.currentTarget.reset(); //2.\n  localStorage.removeItem(STORAGE_KEY); //3.\n}\nformRef.addEventListener('submit', onFormInput);\n\n// когда сложные формы и много полей\n// сделать так чтобы сохраняло не только сообщение но и имя, и все в одном обьекте\nfunction onAllFormsInput(e) {\n  formData[e.target.name] = e.target.value;\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(formData));\n}\nformRef.addEventListener('input', throttle(onAllFormsInput, 500));\n\n/*\n * populateTextarea будет вызываться(выполняться) при загрузке страницы\n * - 1. Получаем значение из хранилища\n * - 2. Всегда нужно проверять есть ли что-то в поле ввода. Eсли да, то выполняем код\n * - 3. Если там что-то было, обновляем DOM\n */\nfunction populateTextarea() {\n  const savedMessage = JSON.parse(localStorage.getItem(STORAGE_KEY)); //1.\n\n  // 2.\n  if (savedMessage) {\n    nameInputRef.value = savedMessage.name; //3.\n    textareaRef.value = savedMessage.message;\n\n    // если у savedMessage есть agreement(тоесть чекбокс выбран) - то выбрать его, а если нет, то не выбирать\n    // не правильно делать тринарник без присваивания или без return, здесь правильно\n    // savedMessage.agreement ? (checkboxRef.checked = true) : (checkboxRef.checked = false);\n\n    checkboxRef.checked = savedMessage.agreement ? true : false;\n\n    // checkboxRef.checked = !!savedMessage.agreement;\n    // checkboxRef.checked = Boolean(savedMessage.agreement);\n\n    // !!savedMessage.agreement === Boolean(savedMessage.agreement);\n\n    // Двойной восклицательный знак - позволяет конвертировать любое выражение в логическое значение. Если выражение, с точки зрения JS, истинно — после обработки его двойным восклицательным знаком будет возвращено true. В противном случае будет возвращено false.\n  }\n}\npopulateTextarea();\n\n// что бы не подключать весь lodash, можно использовать функцию throttle\nfunction throttle(func, ms) {\n  let isThrottled = false;\n  let savedArgs;\n  let savedThis;\n\n  function wrapper() {\n    if (isThrottled) {\n      // (2)\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n\n    func.apply(this, arguments); // (1)\n\n    isThrottled = true;\n\n    setTimeout(function () {\n      isThrottled = false; // (3)\n      if (savedArgs) {\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}\n// --------------------------------------------------------------------------\n// простой вариант - без использвания объекта\n\n// const formRef = document.querySelector('.js-feedback-form');\n// const textareaRef = document.querySelector('.js-feedback-form textarea');\n\n// константа - константное значение между разными запусками скрипта\n// const STORAGE_KEY = 'feedback-message';\n\n// /*\n//  * - 1. Остановить(запретить) поведение по умолчанию\n//  * - 2. Убираем сообщение из хранилища (метод reset - сбрасывает значение всех полей в начальное значение)\n//  * - 3. Очищаем форму после отправки сообщения (oчищаем localStorage)\n//  */\n// function onFormInput(e) {\n//   // имитация отправки формы\n//   e.preventDefault(); //1.\n\n//   // console.log('Отправляем форму');\n\n//   // e.currentTarget - это сейчас форма, потому что onFormInput сейчас висит на formRef\n//   // нельзя писать this.reset() - в этих методах нельзя надеется на контекст\n//   e.currentTarget.reset(); //2.\n\n//   localStorage.removeItem(STORAGE_KEY); //3.\n// }\n// formRef.addEventListener('submit', onFormInput);\n\n// /*\n//  * - 1. Получаем значение(данные) поля textarea при вводе\n//  * - 2. Сохраняем его в хранилище\n//  * - 3. Можно добавить throttle\n//  */\n// function onTextareaInput(e) {\n//   const message = e.target.value; //1.\n\n//   // const message = e.currentTarget.value; //из-за всплытия буду ошибки, не использовать\n//   // console.log(message);\n\n//   localStorage.setItem(STORAGE_KEY, message); //2.\n//   //value текстареи - это строка.\n//   // т.е. стрингифаить (JSON.stringify(message)) не нужно, стрингифаят только массивы и объекты\n// }\n// textareaRef.addEventListener('input', throttle(onTextareaInput, 500));\n\n// /*\n// //\n//  * populateTextarea будет вызываться(выполняться) при загрузке страницы\n//  * - 1. Получаем значение из хранилища\n//  * - 2. Всегда нужно проверять есть ли что-то в поле ввода. если да, то выполняем код\n//  * - 3. Если там что-то было, обновляем DOM\n//  */\n// function populateTextarea() {\n//   const savedMessage = localStorage.getItem(STORAGE_KEY); //1.\n\n//   // 2.\n//   if (savedMessage) {\n//     // console.log(savedMessage);\n//     textareaRef.value = savedMessage; //3.\n//   }\n// }\n// populateTextarea();\n"]}